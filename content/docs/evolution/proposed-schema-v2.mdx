---
title: "Proposed Schema V2"
description: "A redesigned schema addressing the [current limitations](/docs/current-limitations)."
---


A redesigned schema addressing the [current limitations](/docs/current-limitations).

---

## Executive Summary

### The Problem We're Solving

The V1 schema evolved organically over time, leading to several pain points:

1. **"God Object" Fields** - Every field carries 50+ properties, most irrelevant to its type
2. **Tangled Concerns** - Data validation, UI styling, and business logic mixed in one place
3. **Hidden Dependencies** - Cascading dropdowns, computed fields have implicit relationships
4. **Limited Reusability** - Copy-paste is the only way to reuse field configurations
5. **Forms Only** - No support for static pages, dashboards, or wizards
6. **Implicit State** - Variables and computed values stored as "hidden fields"

### The Solution: Layered Architecture

V2 introduces a **clean separation into 5 distinct layers**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      SCHEMA V2                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  MODEL        â”‚  What data exists (fields, variables)       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  UI           â”‚  How it looks (layout, theme, components)   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  LOGIC        â”‚  How it behaves (computed, validation, fx)  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  INTEGRATIONS â”‚  External data (APIs, master data)          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ACCESS       â”‚  Who can do what (roles, permissions)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Each layer is independent and focused. A developer working on UI doesn't need to wade through validation rules. A data architect can define the model without worrying about styling.

---

## Design Principles

### 1. Separation of Concerns
**Why?** When everything is in one place, small changes cascade unpredictably. By isolating data, UI, logic, and access into separate sections, each concern can evolve independently.

**Example Problem (V1):**
```yaml
# V1: Everything mixed together
firstName:
  type: "text"
  label: "First Name"           # UI
  required: true                # Validation
  visible: true                 # Access/Logic
  editable: true                # Access
  placeholder: "Enter name"     # UI
  minLength: 2                  # Validation
  onChange: "calculateFull"     # Logic
  style: { color: "blue" }      # UI
```

**Solution (V2):** Split into appropriate layers, each concern in its place.

### 2. Type Safety
**Why?** In V1, a "number" field still carries string-specific properties like `minLength` and `pattern`. This causes confusion and runtime errors.

**V2 Approach:** Each field type only has properties that make sense for it. A number field has `min`/`max`, not `minLength`/`maxLength`.

### 3. Composition
**Why?** Address blocks appear in 15 different forms. In V1, you copy-paste 30 lines each time. In V2, define once, reference everywhere.

### 4. Flexibility
**Why?** Business needs evolved beyond forms. We need marketing pages, admin dashboards, multi-step wizards. V2 supports all these as first-class citizens.

### 5. Explicit State
**Why?** V1 uses "hidden fields" for computed values and temporary variables. This pollutes the data model and causes confusion about what's user input vs. calculated.

### 6. API-First
**Why?** Modern apps need dynamic data. V1 bolted on API support awkwardly. V2 makes external integrations a core feature with proper caching, error handling, and response mapping.

### 7. Progressive Migration
**Why?** We can't rewrite 500+ forms overnight. V2 must coexist with V1, with automatic transformation where possible.

---

## High-Level Structure

```yaml
# Schema V2 Structure
schema:
  version: "2.0.0"
  type: "form" | "page" | "wizard" | "dashboard"
  
  # Metadata
  meta:
    id: "uuid"
    name: "Customer Registration"
    description: "..."
    
  # Data model (what data exists)
  model:
    fields: { ... }
    variables: { ... }
    
  # UI definition (how it looks)
  ui:
    pages: [ ... ]
    layout: { ... }
    theme: { ... }
    
  # Logic (how it behaves)  
  logic:
    computed: { ... }
    validations: { ... }
    effects: { ... }
    
  # External integrations
  integrations:
    apis: { ... }
    masters: { ... }
    
  # Access control
  access:
    roles: { ... }
    rules: { ... }
```

### Understanding the Structure

Think of this like building a house:

| Layer | House Analogy | Purpose |
|-------|---------------|---------|
| **model** | Blueprint | Defines WHAT rooms exist (data structure) |
| **ui** | Interior Design | Defines HOW it looks (layout, colors, furniture) |
| **logic** | Electrical/Plumbing | Defines HOW it works (switches, flows, automation) |
| **integrations** | Utilities | External connections (water, electricity, internet) |
| **access** | Security System | WHO can enter WHERE |

This separation means:
- A data architect works on `model` without touching UI code
- A designer modifies `ui` without breaking business logic
- A backend developer adds `integrations` independently
- Security rules in `access` don't pollute field definitions

---

## 1. Model Layer (Data Definition)

### Why a Separate Model Layer?

**The Core Insight:** Data structure should be independent of how it's displayed.

In V1, fields are tightly coupled to their UI representation. A "phone number" is defined where it's displayed, with UI concerns (label, placeholder) mixed with data concerns (validation, type).

**V2 Separates These:**
- `model` = Pure data definition (what data, what type, what constraints)
- `ui` = Presentation (how to show it, what label, what placeholder)

**Benefits:**
1. **Reuse data definitions** across different UIs (mobile vs. web vs. PDF)
2. **Generate documentation** from model alone
3. **API contracts** derived from model
4. **Type-safe code generation** possible

### Fields (User Input)

#### The "Slim Field" Philosophy

**Problem in V1:** The `SchemaProperty` class has 50+ properties. Every field carries all of them, even if irrelevant:

```java
// V1: Every field has EVERYTHING
public class SchemaProperty {
    String type;
    String label;
    Boolean required;
    Integer minLength;      // Only for text
    Integer maxLength;      // Only for text  
    Double min;             // Only for numbers
    Double max;             // Only for numbers
    String pattern;         // Only for text
    List<String> accept;    // Only for files
    Integer maxSize;        // Only for files
    Boolean geoTagging;     // Only for location
    // ... 40 more properties
}
```

A "rating" field still has `geoTagging`, `accept`, `minLength` properties - they're just null/ignored.

**V2 Solution: Type-Specific Definitions**

Each field type is a distinct definition with ONLY relevant properties:

```
TextField      â†’ minLength, maxLength, pattern
NumberField    â†’ min, max, integer, decimals  
SelectField    â†’ options, multi, searchable
FileField      â†’ accept, maxSize, capture
LocationField  â†’ geoTagging, manualPick, accuracy
```

**Benefits:**
1. **Clarity** - Reading a field definition shows only what matters
2. **Validation** - Schema validators can enforce correct properties per type
3. **IDE Support** - Autocomplete shows relevant options only
4. **Documentation** - Each type is self-documenting
5. **Smaller Payloads** - No null properties transmitted

#### Field Type Reference

```yaml
model:
  fields:
    # Text field - only text-relevant properties
    firstName:
      type: "text"
      validation:
        required: true
        minLength: 2
        maxLength: 50
        pattern: "^[A-Za-z ]+$"
    
    # Email - inherits text + email validation
    email:
      type: "email"
      validation:
        required: true
    
    # Number - numeric properties
    quantity:
      type: "number"
      validation:
        min: 0
        max: 1000
        integer: true
    
    # Select - selection properties
    country:
      type: "select"
      options:
        source: "static"  # or "api" or "master"
        values: ["India", "USA", "UK"]
      multi: false
    
    # Date - date properties
    birthDate:
      type: "date"
      format: "DD/MM/YYYY"
      validation:
        maxOffset: { value: 0, unit: "day" }  # Past dates only
    
    # File - file properties
    photo:
      type: "file"
      accept: ["image/*"]
      maxSize: "5MB"
      capture: "camera"
    
    # Location - location properties
    siteLocation:
      type: "location"
      geoTagging: true
      manualPick: true
    
    # Group (object) - nested fields
    address:
      type: "group"
      fields:
        street: { type: "text" }
        city: { type: "text" }
        pincode: { type: "text", validation: { pattern: "^[0-9]{6}$" } }
    
    # Repeater (array) - repeating rows
    familyMembers:
      type: "repeater"
      item:
        type: "group"
        fields:
          name: { type: "text", validation: { required: true } }
          relation: { type: "select", options: { values: ["Spouse", "Child"] } }
      validation:
        minItems: 0
        maxItems: 10
```

### Variables (Non-User Data)

#### Why Variables Are Separate from Fields

**The Fundamental Problem:**

In V1, everything is a "field" - even values that users never see or input:

```yaml
# V1: Hidden fields masquerading as data
sessionId:
  type: "text"
  visible: false      # User never sees this
  editable: false     # User can't edit
  defaultValue: "computed:uuid()"

calculatedTotal:
  type: "number"
  visible: false      # Display only
  editable: false
  formula: "subtotal * 1.18"
```

**Problems with this approach:**
1. **Polluted data model** - Submission includes internal variables
2. **Confusing semantics** - Is `visible: false` + `editable: false` a "variable"?
3. **No lifecycle control** - When should temp values reset?
4. **Storage waste** - Computed values shouldn't be persisted

**V2 Solution: Explicit Variables**

Variables are a separate concept with clear semantics:

```yaml
model:
  # Fields = User Input (persisted, submitted)
  fields:
    subtotal: { type: "number" }
    
  # Variables = System Values (not submitted)
  variables:
    _total: { type: "number", computed: "subtotal * 1.18" }
    _sessionId: { type: "string", computed: "uuid()" }
```

**Variable Scopes Explained:**

| Scope | Lifetime | Use Case |
|-------|----------|----------|
| `page` | Reset when leaving page | Temporary UI state, intermediate calculations |
| `form` | Persist across pages | Session IDs, running totals, cached API data |
| `global` | Persist across forms | User preferences, app state |

```yaml
model:
  variables:
    # Page-scoped (reset on page change)
    _tempSubtotal:
      type: "number"
      scope: "page"
    
    # Form-scoped (persist across pages)
    _sessionId:
      type: "string"
      scope: "form"
      computed: "uuid()"
    
    # Derived from API
    _priceFromApi:
      type: "number"
      scope: "form"
```

**Naming Convention:** Variables prefixed with `_` to distinguish from fields at a glance.

---

## 2. UI Layer (Presentation)

### Why a Separate UI Layer?

**The Core Insight:** The same data can be presented many different ways.

Consider a "customer" record:
- **Mobile form**: Single-column, large touch targets, camera integration
- **Web form**: Multi-column grid, keyboard shortcuts, drag-drop
- **PDF export**: Print-optimized layout, formal styling
- **API response**: Just the data, no UI

In V1, data and UI are intertwined. Changing how a field looks requires modifying its data definition.

**V2 Benefits:**
1. **Multiple presentations** of same data model
2. **Theme changes** don't touch business logic
3. **Responsive design** as configuration, not code
4. **UI-specific features** (animations, transitions) isolated

### Pages

#### The Multi-Page Problem in V1

**V1 Approach:** Pages are faked using "section" fields with `pageBreak: true`:

```yaml
# V1: Awkward page simulation
personalSection:
  type: "section"
  label: "Personal Info"
  pageBreak: true
  
firstName:
  type: "text"
  section: "personalSection"
  
addressSection:
  type: "section"
  label: "Address"
  pageBreak: true    # <-- This creates a "page"
```

**Problems:**
- Pages are implicit (section with `pageBreak`)
- No direct page navigation control
- No page-level validation
- No conditional page skipping

**V2 Solution:** Pages are first-class citizens:

```yaml
ui:
  pages:
    - id: "personal"
      title: "Personal Information"
      description: "Basic details"
      fields:
        - "firstName"
        - "lastName" 
        - "email"
        - "phone"
      navigation:
        next:
          condition: "model.email != null"
          label: "Continue"
        
    - id: "address"
      title: "Address"
      fields:
        - "address"  # References the group
      navigation:
        previous: true
        next: true
        skip:
          condition: "model.sameAsRegistered == true"
          
    - id: "review"
      title: "Review & Submit"
      type: "summary"  # Special page type
      submit:
        label: "Submit Application"
```

### Layout

#### The Layout Problem in V1

**V1 Approach:** Layout is implicit, based on field order:

```yaml
# V1: Fields appear in definition order
firstName: { type: "text" }
lastName: { type: "text" }
email: { type: "text" }
# Hope the runtime stacks them nicely...
```

**Problems:**
- No control over multi-column layouts
- Can't place fields side-by-side
- No responsive breakpoints
- Field groups can't be styled together

**V2 Solution:** Explicit, powerful layout system:

```yaml
ui:
  layout:
    # Default layout for all pages
    default:
      type: "stack"       # Vertical stack
      spacing: 16         # 16px between fields
      
    # Page-specific overrides
    pages:
      personal:
        type: "grid"
        columns: 2
        rows:
          - ["firstName", "lastName"]   # Side by side
          - ["email", "phone"]          # Side by side
          - ["birthDate", "."]          # . = empty cell (birthDate alone)
          
    # Field-specific layout
    fields:
      address:
        type: "card"              # Wrap in a card
        collapsible: true         # Can collapse
        defaultExpanded: false    # Start collapsed
```

#### Layout Types Explained

| Type | Use Case | Example |
|------|----------|---------|
| `stack` | Vertical list of fields | Simple forms, mobile |
| `grid` | Rows and columns | Desktop forms with side-by-side fields |
| `card` | Grouped fields in a box | Address blocks, sections |
| `tabs` | Switchable content areas | Dense forms with categories |
| `accordion` | Collapsible sections | Long forms, optional sections |

### Components

#### The Reusability Problem in V1

**V1 Reality:** No reusability mechanism. Address blocks appear in 20 forms? Copy-paste 30 lines each time.

```yaml
# V1: Copy this to every form that needs an address
homeStreet: { type: "text", label: "Street" }
homeCity: { type: "text", label: "City" }
homeState: { type: "select", label: "State", options: [...] }
homePincode: { type: "text", label: "Pincode", pattern: "^[0-9]{6}$" }

# Now copy again for office address
officeStreet: { type: "text", label: "Street" }
officeCity: { type: "text", label: "City" }
# ... and so on
```

**Problems:**
- Bug in address validation? Fix in 20 places
- Added a new field (landmark)? Add to 20 forms
- Inconsistent implementations across forms

**V2 Solution:** Define once, reference everywhere:

```yaml
ui:
  components:
    # Define reusable component ONCE
    AddressBlock:
      type: "group"
      layout:
        type: "stack"
      fields:
        street: 
          type: "text"
          ui: { multiline: true, rows: 2 }
        city:
          type: "text"
        state:
          type: "select"
          options: { source: "master", masterId: "states" }
        pincode:
          type: "text"
          validation: { pattern: "^[0-9]{6}$" }
          
# Usage in fields - reference, don't repeat
model:
  fields:
    homeAddress:
      $ref: "#/ui/components/AddressBlock"    # Use component
    officeAddress:
      $ref: "#/ui/components/AddressBlock"    # Use same component
```

**Benefits:**
1. **Single source of truth** - Fix once, fixed everywhere
2. **Consistency** - All addresses behave identically
3. **Easier maintenance** - Add landmark field in one place
4. **Smaller schemas** - References instead of duplicates

### Theme

#### The Styling Problem in V1

**V1 Approach:** Styling is scattered across field definitions:

```yaml
# V1: Styles embedded in fields
firstName:
  type: "text"
  style:
    labelColor: "#333"
    borderColor: "#ccc"
    borderRadius: 4
    
lastName:
  type: "text"
  style:
    labelColor: "#333"     # Repeated!
    borderColor: "#ccc"    # Repeated!
    borderRadius: 4        # Repeated!
```

**Problems:**
- Change primary color? Edit 50 fields
- No design system / tokens
- Inconsistent styling across fields
- Hard to implement dark mode

**V2 Solution:** Centralized theme with design tokens:

```yaml
ui:
  theme:
    # Color palette - change once, affects everything
    colors:
      primary: "#007AFF"
      secondary: "#5856D6"
      success: "#34C759"
      warning: "#FF9500"
      error: "#FF3B30"
      background: "#F2F2F7"
      surface: "#FFFFFF"
      text: "#000000"
      textSecondary: "#8E8E93"
      
    # Typography scale
    typography:
      fontFamily: "SF Pro"
      sizes:
        h1: 28
        h2: 22
        h3: 18
        body: 16
        caption: 14
        
    # Spacing scale (consistent rhythm)
    spacing:
      xs: 4
      sm: 8
      md: 16
      lg: 24
      xl: 32
      
    # Border radius tokens
    borderRadius:
      sm: 4
      md: 8
      lg: 16
      
    # Shadow tokens
    shadows:
      sm: "0 1px 2px rgba(0,0,0,0.1)"
      md: "0 4px 8px rgba(0,0,0,0.1)"
```

**Benefits:**
1. **Brand consistency** - One place to define brand colors
2. **Dark mode** - Swap theme, entire form updates
3. **Design tokens** - Designers and developers share vocabulary
4. **Responsive** - Different themes for mobile vs. desktop

### Field UI Configuration

#### Separating Data from Display

**Key Insight:** A field's **data type** is different from its **display type**.

- `email` (data) can be shown as text input, chip, or link
- `country` (data) can be shown as dropdown, radio buttons, or chips
- `quantity` (data) can be shown as input, stepper, or slider

**V1 Problem:** These are mixed together:

```yaml
# V1: Data and display tangled
email:
  type: "text"              # Data type
  inputType: "email"        # Display type
  label: "Email"            # Display
  required: true            # Validation
  placeholder: "..."        # Display
```

**V2 Solution:** Model defines data, UI defines display:

```yaml
# Model: Pure data
model:
  fields:
    email:
      type: "email"
      validation: { required: true }
      
# UI: Pure display
ui:
  fields:
    email:
      label: "Email Address"
      placeholder: "you@example.com"
      hint: "We'll send confirmation here"
      keyboard: "email"              # Mobile keyboard type
```

#### UI Configuration Reference

```yaml
ui:
  fields:
    firstName:
      label: "First Name"
      placeholder: "Enter your first name"
      hint: "As it appears on your ID"
      icon: "person"
      
    email:
      label: "Email Address"
      placeholder: "you@example.com"
      hint: "We'll send confirmation here"
      keyboard: "email"
      
    quantity:
      label: "Quantity"
      prefix: "Qty:"
      suffix: "units"
      stepper: true  # Show +/- buttons instead of raw input
      
    country:
      label: "Country"
      searchable: true
      layout: "dropdown"  # or "radio" or "chips"
      
    photo:
      label: "Profile Photo"
      cameraHint: "Position your face in the frame"
      showPreview: true
```

**Why This Separation Matters:**

| Concern | Where | Example |
|---------|-------|---------|
| What data is stored | `model.fields` | `type: "number"` |
| What values are valid | `model.fields.validation` | `min: 0, max: 100` |
| What user sees | `ui.fields` | `label: "Age"` |
| How input behaves | `ui.fields` | `stepper: true` |

---

## 3. Logic Layer (Behavior)

### Why a Separate Logic Layer?

**The Core Problem:** Business logic is scattered and hidden.

In V1, logic lives in field definitions via cryptic string expressions:

```yaml
# V1: Logic hidden in field properties
total:
  type: "number"
  formula: "subtotal * 1.18"        # Where does this run?
  
discount:
  type: "number"
  visible: "total > 1000"           # Is this a string? A condition?
  
status:
  type: "text"
  onChange: "validateAndCompute"    # What does this do?
```

**Problems:**
1. **Hidden dependencies** - Which fields affect which?
2. **Execution order unclear** - Does `total` compute before or after `discount`?
3. **String-based logic** - No syntax checking, no IDE support
4. **Scattered rules** - Visibility, validation, computation all mixed

**V2 Solution:** Dedicated logic layer with explicit definitions:

```yaml
logic:
  # All computations in one place
  computed: { ... }
  
  # All validations in one place  
  validations: { ... }
  
  # All side effects in one place
  effects: { ... }
  
  # All visibility rules in one place
  visibility: { ... }
```

**Benefits:**
1. **Visible dependencies** - Each rule declares what it depends on
2. **Predictable execution** - Clear ordering rules
3. **Testable** - Logic can be unit tested independently
4. **Debuggable** - Easy to trace why a value changed

---

### Computed Fields

#### The Computation Problem in V1

V1 uses a `formula` property on fields:

```yaml
# V1: Formula buried in field
total:
  type: "number"
  formula: "subtotal * (1 - discount / 100)"
  # When does this run? What triggers recalculation?
```

**Problems:**
- No explicit dependency declaration
- Runtime must parse formula to find dependencies
- No support for complex/conditional calculations
- Circular dependency detection is hard

**V2 Solution:** Explicit computed field definitions:

```yaml
logic:
  computed:
    # Simple calculation
    fullName:
      formula: "concat(model.firstName, ' ', model.lastName)"
      dependencies: ["firstName", "lastName"]
      
    # Conditional calculation
    total:
      formula: "model.subtotal * (1 - model.discount / 100)"
      dependencies: ["subtotal", "discount"]
      
    # Array aggregation
    itemsTotal:
      formula: "sum(model.items, 'price')"
      dependencies: ["items"]
      
    # With conditions
    shippingCost:
      formula: |
        if (model.total > 1000) {
          return 0;
        } else if (model.country == 'India') {
          return 50;
        } else {
          return 200;
        }
      dependencies: ["total", "country"]
```

### Validations

#### The Validation Problem in V1

**V1 Approach:** Validation rules embedded in field definitions:

```yaml
# V1: Validation scattered across fields
startDate:
  type: "date"
  required: true
  
endDate:
  type: "date"
  required: true
  # How to validate endDate > startDate? No good place!
```

**Problems:**
1. **Cross-field validation** - Where does "end date must be after start date" go?
2. **Conditional validation** - "Company name required IF employed" - complex string logic
3. **Async validation** - "Email must be unique" requires API call - no support

**V2 Solution:** Dedicated validation section with three types:

#### 1. Cross-Field Validation (Form-Level Rules)

```yaml
logic:
  validations:
    dateRange:
      condition: "model.endDate > model.startDate"
      message: "End date must be after start date"
      fields: ["startDate", "endDate"]  # Which fields to mark as invalid
```

#### 2. Conditional Validation (Dynamic Requirements)

```yaml
logic:
  validations:
    companyRequired:
      condition: "model.employmentType == 'Employed'"  # When to apply
      validate:
        field: "companyName"
        required: true
        message: "Company name required for employed applicants"
```

#### 3. Async Validation (Server-Side Checks)

```yaml
logic:
  validations:
    emailUnique:
      field: "email"
      async: true                    # Runs against server
      api: "validateEmail"           # API to call
      debounce: 500                  # Wait 500ms after typing stops
      message: "Email already registered"
```

**Validation Execution Order:**
1. Field-level (in model) - type, required, min/max
2. Cross-field (in logic) - relationships between fields
3. Async (in logic) - server-side checks
4. Form-level (on submit) - final validation pass

### Effects (Side Effects)

#### What Are Effects?

**Effects** are actions that happen in response to events. They're the "cause and effect" of your form.

| Trigger | Effect |
|---------|--------|
| User selects state | Clear district, fetch new districts |
| User enters address page | Load states from API |
| User checks "Same as billing" | Copy billing address to shipping |
| Form submits | Calculate totals, validate all |

#### The Effects Problem in V1

**V1 Approach:** Side effects hidden in field properties:

```yaml
# V1: Effects buried and unclear
state:
  type: "select"
  onChange: "clearDistrictAndFetch"   # What does this do?
  onChangeParams: { ... }             # Magic parameters
```

**Problems:**
- What triggers what is unclear
- Complex effects need custom code
- No way to sequence multiple actions
- Page-level events not supported

**V2 Solution:** Explicit effect definitions with clear triggers and actions:

```yaml
logic:
  effects:
    # On field change - User selects a state
    onStateChange:
      trigger: { field: "state", event: "change" }
      actions:
        - clear: ["district", "city"]                    # Clear dependent fields
        - fetch: { api: "getDistricts", params: { stateId: "model.state" } }
        
    # On page enter - User navigates to address page
    onAddressPageEnter:
      trigger: { page: "address", event: "enter" }
      actions:
        - fetch: { api: "getStates" }                    # Preload data
        
    # On form submit - Before data is sent
    beforeSubmit:
      trigger: { form: true, event: "beforeSubmit" }
      actions:
        - validate: { all: true }                        # Run all validations
        - compute: ["fullName", "total"]                 # Calculate final values
        
    # Conditional effect - Only runs if condition is true
    autoFillProfile:
      trigger: { field: "useProfile", event: "change" }
      condition: "model.useProfile == true"              # Guard condition
      actions:
        - copy: 
            from: "user.profile"
            to: ["firstName", "lastName", "email", "phone"]
```

#### Available Effect Actions

| Action | Purpose | Example |
|--------|---------|---------|
| `clear` | Reset field values | `clear: ["district", "city"]` |
| `set` | Set a field value | `set: { field: "status", value: "pending" }` |
| `fetch` | Call an API | `fetch: { api: "getDistricts" }` |
| `copy` | Copy values between fields | `copy: { from: "billing", to: "shipping" }` |
| `validate` | Run validation | `validate: { fields: ["email"] }` |
| `compute` | Recalculate computed fields | `compute: ["total", "tax"]` |
| `navigate` | Go to another page | `navigate: { page: "summary" }` |
| `show` / `hide` | Toggle visibility | `show: ["advancedOptions"]` |

### Visibility Rules

#### The Visibility Problem in V1

**V1 Approach:** Visibility as a field property:

```yaml
# V1: Visibility mixed with data definition
middleName:
  type: "text"
  visible: "hasMiddleName == true"   # String expression - fragile
  
adminNotes:
  type: "text"
  visible: "user.role == 'admin'"    # Access control mixed in
```

**Problems:**
- Visibility rules scattered across 50 fields
- Hard to see "what shows when" at a glance
- Mixes access control with conditional display
- No page-level visibility

**V2 Solution:** Centralized visibility rules:

```yaml
logic:
  visibility:
    # Simple condition - show field based on another field's value
    middleName:
      visible: "model.hasMiddleName == true"
      
    # Role-based - access control (different from conditional display!)
    adminSection:
      visible: "user.role == 'admin'"
      
    # Complex condition - multiple factors
    discountField:
      visible: "model.customerType == 'Premium' && model.total > 1000"
      
    # Page-level visibility - skip entire pages
    pages:
      address:
        skip: "model.sameAsRegistered == true"
```

#### Visibility vs. Access Control

Important distinction:

| Concept | Purpose | Example |
|---------|---------|---------|
| **Visibility** | Show/hide based on form state | "Show spouse details if married" |
| **Access** | Show/hide based on user role | "Only admins see audit log" |

V2 keeps these separate:
- Conditional visibility â†’ `logic.visibility`
- Role-based access â†’ `access.rules`

---

### Cascading Fields (Option Filter)

> **See [OPTION_FILTER Deep Analysis](/docs/option-filter-analysis) for complete behavior spec.**

#### What Are Cascading Fields?

**Cascading fields** are dependent dropdowns where selecting a parent filters the options in a child.

```
State â†’ District â†’ Block â†’ Village
  â†“         â†“         â†“         â†“
Select   Filters   Filters   Filters
"UP"     to UP     to UP     to UP
         districts  blocks    villages
```

#### The Cascade Problem in V1

**V1 Approach:** Cascades configured via `OPTION_FILTER` in field definition:

```yaml
# V1: Cascade configuration is verbose and unclear
district:
  type: "select"
  options:
    source: "master"
    masterId: "locations"
    column: "d"
  optionFilter:
    - field: "state"
      column: "s"
      operator: "eq"
  # What happens when state is cleared?
  # What happens during loading?
  # What if no districts match?
  # No clear answers!
```

**Problems:**
1. **Undefined behaviors** - What happens when parent is cleared?
2. **Race conditions** - User changes state while districts are loading
3. **No feedback** - User doesn't know why field is disabled
4. **Inconsistent** - Different forms handle edge cases differently

**V2 Solution:** Explicit cascade definitions with ALL behaviors defined:

```yaml
logic:
  cascades:
    locationCascade:
      # Define the chain - makes the relationship explicit
      chain: ["state", "district", "block", "village"]
      
      # What happens when parent changes
      onParentChange: "clear"  # clear | keep | validate
      
      # Should clearing cascade down the chain?
      cascadeDownstream: true  # state cleared â†’ clear district, block, village
      
      # What to show when parent is empty
      emptyParentBehavior: "disable"  # disable | showAll | showNone
      emptyParentHint: "Select {parentLabel} first"
      
      # Loading states - user feedback
      showLoadingState: true
      
      # No results handling
      noMatchBehavior:
        message: "No {fieldLabel} found for selected {parentLabel}"
        allowManualEntry: false
```

#### Cascade Behavior Matrix

Every edge case is explicitly defined:

| Scenario | Behavior Option | Default |
|----------|-----------------|---------|
| Parent cleared | `clear` / `keep` / `validate` | `clear` |
| Parent changed | Clear if invalid, else keep | - |
| Parent empty | `disable` / `showAll` / `showNone` | `disable` |
| Options loading | Show spinner, disable input | - |
| No matches found | Show message, optionally allow manual | - |
| Race condition | Cancel stale requests, use latest | - |

**Alternative: Per-field cascade config**

```yaml
fields:
  district:
    type: "select"
    options:
      masterRef: "locations"
      column: "d"
      
      # Filter configuration
      filter:
        parentField: "state"
        parentColumn: "s"
        
        # Cascade behavior
        onParentChange: "clear"
        cascadeDownstream: true
        
        # Empty parent
        emptyParentBehavior: "disable"
        emptyParentHint: "Select state first"
        
        # Multi-parent (AND/OR)
        # logic: "AND"  # For multiple parents
        
      # Loading UX
      loadingText: "Loading districts..."
      noMatchText: "No districts found"
```

**Defined behaviors:**

| Scenario | Behavior |
|----------|----------|
| Parent cleared | Clear this field + all downstream |
| Parent changed | Clear if value invalid, else keep |
| Parent empty | Disable field, show hint |
| Filter loading | Show spinner, disable input |
| No matches | Show message, optionally allow manual |
| Race condition | Cancel stale requests, use latest |

---

## 4. Integrations Layer

### Why a Separate Integrations Layer?

**The Core Problem:** Forms increasingly need external data, but V1 wasn't designed for this.

Modern forms need to:
- Fetch dropdown options from APIs
- Validate data against servers (email uniqueness)
- Look up prices, inventory, customer info
- Submit to external systems

**V1 Approach:** External data is an afterthought:

```yaml
# V1: API integration is ad-hoc
productPrice:
  type: "number"
  source: "api"
  apiUrl: "/products/{productId}/price"   # Hardcoded
  apiMethod: "GET"                         # Scattered config
  # Error handling? Caching? Loading states? ğŸ¤·
```

**Problems:**
1. **No centralized API definitions** - Same endpoint configured in multiple fields
2. **No caching** - Same data fetched repeatedly
3. **No error handling** - API fails, form breaks
4. **No loading states** - User doesn't know what's happening
5. **No response mapping** - Complex JSON responses hard to use

**V2 Solution:** First-class API integration layer:

```yaml
integrations:
  apis:
    # Define ONCE, use everywhere
    getProductPrice:
      url: "${env.API_BASE}/products/{{productId}}/price"
      method: "GET"
      cache: 300           # Cache for 5 minutes
      timeout: 5000        # 5 second timeout
      retry: 2             # Retry twice on failure
      response:
        mapping:
          price: "$.data.price"
          stock: "$.data.inventory"
```

---

### API Definitions

#### API Configuration in Detail

```yaml
integrations:
  apis:
    # GET request
    getStates:
      url: "${env.API_BASE}/locations/states"
      method: "GET"
      cache: 3600  # seconds
      response:
        mapping:
          states: "$.data[*].name"
          
    # GET with params
    getDistricts:
      url: "${env.API_BASE}/locations/districts"
      method: "GET"
      params:
        stateId: "{{stateId}}"
      response:
        mapping:
          districts: "$.data[*].name"
          
    # POST request
    validateEmail:
      url: "${env.API_BASE}/validate/email"
      method: "POST"
      body:
        email: "{{email}}"
      response:
        valid: "$.isAvailable"
        message: "$.message"
        
    # Fetch for calculation
    getProductPrice:
      url: "${env.PRICING_API}/products/{{productId}}/price"
      method: "GET"
      response:
        mapping:
          _priceFromApi: "$.price"
          _stockAvailable: "$.inventory"
```

### Master Data

> **See [Master Data Strategy](/docs/master-data-strategy) for complete solution.**

#### The Master Data Problem

**What is Master Data?**
Reference data shared across forms: locations, products, categories, etc.

**Example:** India location hierarchy
- 36 States â†’ 700+ Districts â†’ 6000+ Blocks â†’ 90,000+ Villages

**V1 Approach:** Each field fetches independently:

```yaml
# V1: Each field fetches master data separately
state:
  type: "select"
  masterData:
    id: "locations-uuid"
    column: "s"
    # Fetches entire master

district:
  type: "select"
  masterData:
    id: "locations-uuid"    # Same master!
    column: "d"
    # Fetches entire master AGAIN
```

**Problems:**
1. **Duplicate fetches** - 4 fields using same master = 4 network requests
2. **90,000 rows** - Entire dataset loaded even if user only picks one state
3. **No caching** - Page refresh = fetch everything again
4. **Memory bloat** - Large datasets crash mobile devices
5. **Slow startup** - User waits while masters load

**V2 Solution:** Centralized master registry with intelligent loading:

```yaml
integrations:
  masters:
    # Declare ONCE at form level, all fields share
    locations:
      id: "70311147-2fcc-489c-9981-8f374361a229"
      name: "India Locations"
      
      # Loading strategy
      strategy: "lazy"  # eager | lazy | onDemand
      #   eager    = Load on form open
      #   lazy     = Load when first field needs it
      #   onDemand = Load based on parent selection (partitioned)
      
      # Caching - persist across sessions
      cache:
        storage: "indexedDB"      # Browser storage
        ttl: 86400                # 24 hours before re-fetch
        compression: true         # Compress large datasets
        
      # Partition large datasets - CRITICAL for performance
      partitioning:
        enabled: true
        partitionBy: "s"          # State column
        maxCachedPartitions: 5    # Keep 5 states in memory
      # Result: 90k rows â†’ ~2.5k per state, loaded on demand
        
      # Version tracking for sync
      versioning:
        enabled: true
        checkInterval: 3600       # Check for updates hourly
      # Only downloads changed records, not entire dataset
        
      # What to fetch
      columns: ["s", "d", "b", "v"]
      indexes: ["s", "d", "b"]    # Fast client-side filtering
      
    products:
      id: "product-master-uuid"
      strategy: "onDemand"        # Search-based, not preloaded
      searchable: true
      searchFields: ["name", "sku", "category"]
```

#### Master Data Loading Strategies

| Strategy | When to Use | Example |
|----------|-------------|---------|
| `eager` | Small datasets (under 1000 rows), always needed | Countries, Categories |
| `lazy` | Medium datasets, might not be needed | Products, Vendors |
| `onDemand` | Large datasets, hierarchical | Locations (stateâ†’districtâ†’village) |

#### Key Improvements Over V1

| Problem | V1 | V2 |
|---------|-----|-----|
| Duplicate fetches | Each field fetches | Single fetch, shared |
| Large datasets | Load everything | Partition by parent |
| No persistence | Always fetch | IndexedDB cache |
| Slow sync | Full re-download | Delta updates via versioning |
| Memory usage | Keep all in memory | LRU eviction |

**Field reference syntax:**
```yaml
fields:
  state:
    type: "select"
    options:
      masterRef: "locations"  # Reference, not inline config
      column: "s"
      distinct: true
      
  district:
    type: "select"
    options:
      masterRef: "locations"  # Same reference, shared data
      column: "d"
      filter:
        - field: "state"
          column: "s"
```

---

## 5. Access Layer

### Why a Separate Access Layer?

**The Core Problem:** Access control in V1 is mixed with visibility logic.

**V1 Approach:**

```yaml
# V1: Access control hidden in field properties
salary:
  type: "number"
  visible: "user.role == 'admin' || user.role == 'hr'"    # Access mixed with visibility
  editable: "user.role == 'admin'"                         # Hard to audit
```

**Problems:**
1. **Hard to audit** - Who can see what? Grep through every field
2. **Mixed concerns** - Role-based access looks like conditional visibility
3. **No form-level control** - Can a field agent delete records?
4. **Inconsistent** - Different fields use different role expressions

**V2 Solution:** Dedicated access layer with clear role definitions:

### Role Definitions

**Define roles once, reference everywhere:**

```yaml
access:
  roles:
    - id: "field_agent"
      label: "Field Agent"
      description: "Collects data in the field"
    - id: "supervisor"
      label: "Supervisor"
      description: "Reviews and approves submissions"
    - id: "admin"
      label: "Administrator"
      description: "Full system access"
```

### Access Rules

**Clear, auditable access control:**

```yaml
access:
  rules:
    # Field-level access - Who can see/edit which fields
    fields:
      salary:
        visible: ["admin", "hr"]      # Only these roles see salary
        editable: ["admin"]           # Only admin can edit
        
      status:
        visible: ["*"]                # All roles see status
        editable: ["supervisor", "admin"]  # Only these can change it
        
    # Page-level access - Entire pages restricted
    pages:
      adminSettings:
        visible: ["admin"]
        
    # Form-level access - CRUD permissions
    form:
      create: ["field_agent", "supervisor", "admin"]
      edit: ["supervisor", "admin"]
      delete: ["admin"]
      view: ["*"]
```

#### Access Control Matrix (Easy to Audit)

From the above rules, we can generate:

| Field/Action | Field Agent | Supervisor | Admin | HR |
|--------------|:-----------:|:----------:|:-----:|:--:|
| salary (view) | âŒ | âŒ | âœ… | âœ… |
| salary (edit) | âŒ | âŒ | âœ… | âŒ |
| status (view) | âœ… | âœ… | âœ… | âœ… |
| status (edit) | âŒ | âœ… | âœ… | âŒ |
| Create form | âœ… | âœ… | âœ… | âŒ |
| Edit form | âŒ | âœ… | âœ… | âŒ |
| Delete form | âŒ | âŒ | âœ… | âŒ |

This matrix can be auto-generated from the schema for compliance audits.

---

## 6. Static Pages Support

For non-form content.

```yaml
schema:
  version: "2.0.0"
  type: "page"  # Not a form
  
  meta:
    id: "about-page"
    name: "About Us"
    
  ui:
    layout:
      type: "stack"
      spacing: 24
      
    content:
      - type: "hero"
        title: "About Our Company"
        subtitle: "Building the future of work"
        image: "hero-bg.jpg"
        
      - type: "text"
        content: |
          We are a leading provider of enterprise solutions...
        style:
          fontSize: 16
          lineHeight: 1.6
          
      - type: "cards"
        layout: "grid"
        columns: 3
        items:
          - icon: "rocket"
            title: "Our Mission"
            text: "..."
          - icon: "users"
            title: "Our Team"
            text: "..."
          - icon: "globe"
            title: "Our Reach"
            text: "..."
            
      - type: "cta"
        title: "Ready to get started?"
        button:
          label: "Contact Us"
          action: { navigate: "/contact" }
```

---

## 7. Dashboard Support

For data visualization pages.

```yaml
schema:
  version: "2.0.0"
  type: "dashboard"
  
  meta:
    id: "sales-dashboard"
    name: "Sales Dashboard"
    
  data:
    sources:
      dailySales:
        api: "getDailySales"
        refresh: 300  # seconds
        
      topProducts:
        api: "getTopProducts"
        
  ui:
    layout:
      type: "grid"
      columns: 12
      gap: 16
      
    widgets:
      - type: "metric"
        title: "Total Sales"
        value: "data.dailySales.total"
        format: "currency"
        trend: "data.dailySales.trend"
        span: 3
        
      - type: "chart"
        title: "Sales Trend"
        chartType: "line"
        data: "data.dailySales.history"
        x: "date"
        y: "amount"
        span: 6
        
      - type: "table"
        title: "Top Products"
        data: "data.topProducts"
        columns:
          - field: "name"
            label: "Product"
          - field: "sales"
            label: "Sales"
            format: "number"
        span: 12
```

---

## 8. Versioning & Migration

```yaml
schema:
  version: "2.1.0"
  
  migrations:
    "2.0.0":
      # From 2.0.0 to 2.1.0
      - rename:
          from: "fname"
          to: "firstName"
      - transform:
          field: "phone"
          formula: "'+91' + value.replace(/[^0-9]/g, '')"
      - addField:
          name: "middleName"
          default: ""
      - removeField:
          name: "legacyField"
```

---

## 9. Type Definitions

For tooling and validation.

```typescript
// TypeScript interfaces for schema validation

interface SchemaV2 {
  version: string;
  type: "form" | "page" | "wizard" | "dashboard";
  meta: SchemaMeta;
  model?: ModelDefinition;
  ui: UIDefinition;
  logic?: LogicDefinition;
  integrations?: IntegrationsDefinition;
  access?: AccessDefinition;
}

interface FieldDefinition {
  type: FieldType;
  validation?: FieldValidation;
}

type FieldType = 
  | TextFieldDef
  | NumberFieldDef
  | SelectFieldDef
  | DateFieldDef
  | FileFieldDef
  | LocationFieldDef
  | GroupFieldDef
  | RepeaterFieldDef;

interface TextFieldDef {
  type: "text" | "email" | "phone" | "url";
  validation?: {
    required?: boolean;
    minLength?: number;
    maxLength?: number;
    pattern?: string;
  };
}

interface NumberFieldDef {
  type: "number" | "currency" | "percentage";
  validation?: {
    required?: boolean;
    min?: number;
    max?: number;
    integer?: boolean;
  };
}

// ... etc
```

---

## Migration Strategy

### Phase 1: Parallel Support
- V2 schema processor alongside V1
- Transform V1 to V2 at runtime
- New forms use V2

### Phase 2: Tooling
- Schema editor supports V2
- Validation tools
- Migration utilities

### Phase 3: Gradual Migration
- Convert high-priority forms
- Keep V1 runtime for legacy
- Eventually deprecate V1

---

## Quick Reference: How to Read a V2 Schema

When you encounter a V2 schema, here's how to navigate it:

### "I want to understand what data this form collects"
â†’ Look at `model.fields`

### "I want to see how it looks"
â†’ Look at `ui.pages`, `ui.layout`, `ui.fields`

### "I want to understand the business logic"
â†’ Look at `logic.computed`, `logic.validations`, `logic.effects`

### "I want to see what external data it uses"
â†’ Look at `integrations.apis`, `integrations.masters`

### "I want to know who can do what"
â†’ Look at `access.roles`, `access.rules`

---

## Visual: Schema Layer Interaction

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           USER INTERACTION                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  UI LAYER                                                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚   Pages     â”‚  â”‚   Layout    â”‚  â”‚   Theme     â”‚  â”‚ Field UI    â”‚    â”‚
â”‚  â”‚  (wizard)   â”‚  â”‚  (grid)     â”‚  â”‚  (colors)   â”‚  â”‚ (labels)    â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â–¼               â–¼               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    MODEL LAYER       â”‚  â”‚   LOGIC LAYER    â”‚  â”‚   ACCESS LAYER       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Fields (data)  â”‚â—„â”€â”¼â”€â”€â”¼â”€â–ºâ”‚ Computed   â”‚  â”‚  â”‚  â”‚ Roles          â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚  â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚  â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚ Variables      â”‚â—„â”€â”¼â”€â”€â”¼â”€â–ºâ”‚ Validation â”‚  â”‚  â”‚  â”‚ Rules          â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                      â”‚  â”‚  â”‚ Effects    â”‚  â”‚  â”‚                      â”‚
â”‚                      â”‚  â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚  â”‚                      â”‚
â”‚                      â”‚  â”‚  â”‚ Visibility â”‚  â”‚  â”‚                      â”‚
â”‚                      â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  INTEGRATIONS LAYER                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ APIs (external services)    â”‚  â”‚ Masters (reference data)        â”‚  â”‚
â”‚  â”‚ - Fetch data                â”‚  â”‚ - Locations                     â”‚  â”‚
â”‚  â”‚ - Validate async            â”‚  â”‚ - Products                      â”‚  â”‚
â”‚  â”‚ - Submit                    â”‚  â”‚ - Categories                    â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Visual: Decision Flowchart - Which Layer?

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ What are you defining?  â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚                   â”‚                   â”‚
            â–¼                   â–¼                   â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ Data/Storage? â”‚   â”‚ Presentation? â”‚   â”‚   Behavior?   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚                   â”‚                   â”‚
            â–¼                   â–¼                   â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚    MODEL      â”‚   â”‚      UI       â”‚   â”‚    LOGIC      â”‚
    â”‚               â”‚   â”‚               â”‚   â”‚               â”‚
    â”‚ â€¢ field types â”‚   â”‚ â€¢ labels      â”‚   â”‚ â€¢ formulas    â”‚
    â”‚ â€¢ validation  â”‚   â”‚ â€¢ placeholdersâ”‚   â”‚ â€¢ validations â”‚
    â”‚   constraints â”‚   â”‚ â€¢ layout      â”‚   â”‚ â€¢ effects     â”‚
    â”‚ â€¢ variables   â”‚   â”‚ â€¢ theme       â”‚   â”‚ â€¢ visibility  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚                   â”‚                   â”‚
            â–¼                   â–¼                   â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ External Data?â”‚   â”‚  Permissions? â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚                   â”‚
            â–¼                   â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ INTEGRATIONS  â”‚   â”‚    ACCESS     â”‚
    â”‚               â”‚   â”‚               â”‚
    â”‚ â€¢ APIs        â”‚   â”‚ â€¢ roles       â”‚
    â”‚ â€¢ masters     â”‚   â”‚ â€¢ field perms â”‚
    â”‚ â€¢ caching     â”‚   â”‚ â€¢ form perms  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Comparison: V1 vs V2

| Aspect | V1 (Current) | V2 (Proposed) | Why Change? |
|--------|--------------|---------------|-------------|
| **Field definition** | Fat SchemaProperty (50+ props) | Type-specific slim objects | Clarity, validation, smaller payloads |
| **Pages** | Faked via sections + pageBreak | Native first-class support | Better navigation, page-level logic |
| **Variables** | Hidden fields (visible:false) | Explicit variables with scope | Clear semantics, no data pollution |
| **API integration** | Ad-hoc, per-field | Centralized with caching | Single definition, shared caching |
| **Page types** | Forms only | Forms, pages, wizards, dashboards | Product flexibility |
| **Expressions** | Unvalidated strings | Structured with dependencies | IDE support, validation, debugging |
| **Composition** | Copy-paste | $ref components | DRY, maintainability |
| **Layout** | Implicit (field order) | Explicit grid/flex/stack | Responsive, multi-column |
| **Side effects** | Hidden in onChange | Explicit effects layer | Visible, testable, debuggable |
| **Versioning** | None | Built-in migrations | Safe schema evolution |
| **Theming** | Scattered in fields | Centralized design tokens | Consistent branding, dark mode |
| **State management** | Implicit | Explicit fields vs variables | Predictable data flow |
| **Access control** | AccessMatrix object | Declarative rules | Auditable, consistent |

---

## Complete Example: Customer Registration Form

Here's a complete, annotated V2 schema demonstrating all layers working together:

```yaml
schema:
  version: "2.0.0"
  type: "wizard"                    # Multi-step form
  
  #â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # METADATA - Form identification
  #â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  meta:
    id: "customer-registration-v1"
    name: "Customer Registration"
    description: "Onboard new customers with KYC"
    author: "product-team"
    created: "2024-01-15"
    
  #â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # MODEL - What data exists (pure data, no UI concerns)
  #â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  model:
    fields:
      # Basic text input with validation
      firstName:
        type: "text"
        validation:
          required: true
          minLength: 2
          maxLength: 50
          
      lastName:
        type: "text"
        validation:
          required: true
          
      # Email with built-in format validation
      email:
        type: "email"
        validation:
          required: true
          
      # Phone with pattern
      phone:
        type: "phone"
        validation:
          required: true
          pattern: "^[6-9][0-9]{9}$"  # Indian mobile
          
      # Selection from static options
      customerType:
        type: "select"
        options:
          values: ["Individual", "Business", "Enterprise"]
        validation:
          required: true
          
      # Cascading selection from master data
      state:
        type: "select"
        options:
          masterRef: "locations"
          column: "s"
          distinct: true
          
      district:
        type: "select"
        options:
          masterRef: "locations"
          column: "d"
          filter:
            - field: "state"
              column: "s"
              
      # File upload with constraints
      idProof:
        type: "file"
        accept: ["image/*", "application/pdf"]
        maxSize: "5MB"
        validation:
          required: true
          
      # Location capture
      visitLocation:
        type: "location"
        geoTagging: true
        
    # Variables - computed/temporary values (NOT submitted)
    variables:
      _fullName:
        type: "string"
        scope: "form"
        
      _registrationId:
        type: "string"
        scope: "form"
        computed: "uuid()"
        
  #â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # UI - How it looks (presentation only)
  #â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  ui:
    pages:
      - id: "personal"
        title: "Personal Information"
        description: "Basic details about the customer"
        fields: ["firstName", "lastName", "email", "phone"]
        navigation:
          next:
            condition: "model.email != null && model.phone != null"
            label: "Continue"
            
      - id: "business"
        title: "Business Details"
        fields: ["customerType", "state", "district"]
        navigation:
          previous: true
          next: true
          
      - id: "verification"
        title: "Verification"
        fields: ["idProof", "visitLocation"]
        navigation:
          previous: true
          submit:
            label: "Complete Registration"
            
    layout:
      default:
        type: "stack"
        spacing: 16
        
      pages:
        personal:
          type: "grid"
          columns: 2
          rows:
            - ["firstName", "lastName"]
            - ["email", "phone"]
            
    fields:
      firstName:
        label: "First Name"
        placeholder: "Enter first name"
        icon: "person"
        
      lastName:
        label: "Last Name"
        placeholder: "Enter last name"
        
      email:
        label: "Email Address"
        placeholder: "you@example.com"
        hint: "We'll send confirmation here"
        
      phone:
        label: "Mobile Number"
        placeholder: "10-digit mobile"
        prefix: "+91"
        
      customerType:
        label: "Customer Type"
        layout: "radio"         # Show as radio buttons
        
      state:
        label: "State"
        searchable: true
        
      district:
        label: "District"
        searchable: true
        
      idProof:
        label: "ID Proof"
        hint: "Aadhaar, PAN, or Passport"
        
      visitLocation:
        label: "Visit Location"
        hint: "Capture current location"
        
    theme:
      colors:
        primary: "#2563EB"
        success: "#10B981"
        error: "#EF4444"
        
  #â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # LOGIC - How it behaves (business rules)
  #â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  logic:
    computed:
      _fullName:
        formula: "concat(model.firstName, ' ', model.lastName)"
        dependencies: ["firstName", "lastName"]
        
    validations:
      emailUnique:
        field: "email"
        async: true
        api: "validateEmail"
        debounce: 500
        message: "Email already registered"
        
    effects:
      onStateChange:
        trigger: { field: "state", event: "change" }
        actions:
          - clear: ["district"]
          
    visibility:
      # Show district only after state is selected
      district:
        visible: "model.state != null"
        
    cascades:
      locationCascade:
        chain: ["state", "district"]
        onParentChange: "clear"
        emptyParentBehavior: "disable"
        emptyParentHint: "Select state first"
        
  #â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # INTEGRATIONS - External data sources
  #â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  integrations:
    apis:
      validateEmail:
        url: "${env.API_BASE}/validate/email"
        method: "POST"
        body:
          email: "{{email}}"
        response:
          valid: "$.available"
          message: "$.message"
          
    masters:
      locations:
        id: "india-locations-uuid"
        strategy: "lazy"
        cache:
          storage: "indexedDB"
          ttl: 86400
        partitioning:
          enabled: true
          partitionBy: "s"
          
  #â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # ACCESS - Who can do what
  #â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  access:
    roles:
      - id: "field_agent"
        label: "Field Agent"
      - id: "supervisor"
        label: "Supervisor"
        
    rules:
      form:
        create: ["field_agent", "supervisor"]
        edit: ["supervisor"]
        view: ["*"]
```

---

## Key Takeaways

### 1. Separation = Clarity
Each layer has ONE job. Finding where to change something is obvious.

### 2. Explicit > Implicit
V2 makes hidden behaviors explicit. Cascade rules, visibility conditions, effects - all visible.

### 3. Type-Specific = Safer
Fields only have relevant properties. No more `minLength` on a number field.

### 4. Centralized = Efficient
Master data, themes, components defined once, referenced everywhere.

### 5. Auditable = Compliant
Access rules generate clear permission matrices for compliance.

---

## Next Steps

1. **Validate design** with team
2. **Build transformer** V1 â†’ V2
3. **Implement runtime** for V2
4. **Create schema editor** with V2 support
5. **Migrate pilot forms**
6. **Document migration guide**

